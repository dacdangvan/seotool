/**
 * SEO-Ready Waiter
 * 
 * Utility for waiting until SEO-critical elements are present in the DOM.
 * Prevents false negatives when meta tags are generated by JavaScript.
 * 
 * Per AI_SEO_TOOL_PROMPT_BOOK.md Section 8 & 9
 */

import { Page } from 'playwright';

/**
 * SEO-ready condition result
 */
export interface SeoReadyResult {
  isReady: boolean;
  hasTitle: boolean;
  hasMetaDescription: boolean;
  hasH1: boolean;
  titleValue: string | null;
  metaDescriptionValue: string | null;
  h1Value: string | null;
  waitTime: number;
  timedOut: boolean;
}

/**
 * Timing metrics for render wait
 */
export interface RenderTiming {
  timeToDomReady: number;        // DOMContentLoaded
  timeToNetworkIdle: number;     // Network idle
  timeToSeoReady: number;        // SEO elements present
  totalRenderTime: number;       // Total from navigation start
  seoReadyTimedOut: boolean;     // Whether SEO wait timed out
}

/**
 * Configuration for SEO-ready wait
 */
export interface SeoReadyConfig {
  /** Max time to wait for SEO elements (ms) */
  maxWaitTime: number;
  /** Interval to check for SEO elements (ms) */
  pollInterval: number;
  /** Require title to be non-empty */
  requireTitle: boolean;
  /** Require meta description to be non-empty */
  requireMetaDescription: boolean;
  /** Require H1 to be non-empty */
  requireH1: boolean;
  /** Debug logging */
  debug: boolean;
}

export const DEFAULT_SEO_READY_CONFIG: SeoReadyConfig = {
  maxWaitTime: 15000,       // 15 seconds max
  pollInterval: 200,        // Check every 200ms
  requireTitle: true,
  requireMetaDescription: false, // Some pages legitimately don't have meta description
  requireH1: false,         // Some pages legitimately don't have H1
  debug: false
};

/**
 * Wait for SEO-critical elements to be present in the DOM
 */
export async function waitForSeoReady(
  page: Page,
  config: Partial<SeoReadyConfig> = {}
): Promise<SeoReadyResult> {
  const cfg = { ...DEFAULT_SEO_READY_CONFIG, ...config };
  const startTime = Date.now();
  
  const log = (msg: string) => {
    if (cfg.debug) {
      console.log(`[SeoReadyWaiter] ${msg}`);
    }
  };

  log(`Starting SEO-ready wait (max ${cfg.maxWaitTime}ms)`);

  // Evaluate SEO elements in the page context
  const checkSeoElements = async (): Promise<Omit<SeoReadyResult, 'waitTime' | 'timedOut'>> => {
    return page.evaluate(() => {
      const getTitle = (): string | null => {
        const titleEl = document.querySelector('title');
        const title = titleEl?.textContent?.trim() || null;
        // Check for placeholder/generic titles
        if (title && (
          title.toLowerCase() === 'loading...' ||
          title.toLowerCase() === 'loading' ||
          title === '...' ||
          title.length < 3
        )) {
          return null; // Treat as not ready
        }
        return title;
      };

      const getMetaDescription = (): string | null => {
        const metaEl = document.querySelector('meta[name="description"]');
        const content = metaEl?.getAttribute('content')?.trim() || null;
        // Check for placeholder descriptions
        if (content && (
          content.toLowerCase() === 'loading...' ||
          content.toLowerCase() === 'loading' ||
          content === '...' ||
          content.length < 10
        )) {
          return null; // Treat as not ready
        }
        return content;
      };

      const getH1 = (): string | null => {
        const h1El = document.querySelector('h1');
        return h1El?.textContent?.trim() || null;
      };

      const titleValue = getTitle();
      const metaDescriptionValue = getMetaDescription();
      const h1Value = getH1();

      return {
        hasTitle: !!titleValue,
        hasMetaDescription: !!metaDescriptionValue,
        hasH1: !!h1Value,
        titleValue,
        metaDescriptionValue,
        h1Value,
        isReady: false // Will be calculated below
      };
    });
  };

  // Initial check
  let result = await checkSeoElements();
  let elapsed = Date.now() - startTime;

  // Determine if we're ready based on config requirements
  const isReady = (r: typeof result): boolean => {
    if (cfg.requireTitle && !r.hasTitle) return false;
    if (cfg.requireMetaDescription && !r.hasMetaDescription) return false;
    if (cfg.requireH1 && !r.hasH1) return false;
    // If nothing is required, wait for at least title OR meta description
    if (!cfg.requireTitle && !cfg.requireMetaDescription && !cfg.requireH1) {
      return r.hasTitle || r.hasMetaDescription;
    }
    return true;
  };

  // Poll until ready or timeout
  while (!isReady(result) && elapsed < cfg.maxWaitTime) {
    log(`Waiting... hasTitle=${result.hasTitle}, hasMeta=${result.hasMetaDescription}, hasH1=${result.hasH1} (${elapsed}ms)`);
    
    await page.waitForTimeout(cfg.pollInterval);
    result = await checkSeoElements();
    elapsed = Date.now() - startTime;
  }

  const timedOut = elapsed >= cfg.maxWaitTime && !isReady(result);
  
  log(timedOut 
    ? `Timed out after ${elapsed}ms. Final state: title=${result.hasTitle}, meta=${result.hasMetaDescription}, h1=${result.hasH1}`
    : `SEO ready after ${elapsed}ms. title=${result.hasTitle}, meta=${result.hasMetaDescription}, h1=${result.hasH1}`
  );

  return {
    ...result,
    isReady: isReady(result),
    waitTime: elapsed,
    timedOut
  };
}

/**
 * Wait for specific SEO element with selector
 */
export async function waitForSeoElement(
  page: Page,
  selector: string,
  options: { timeout?: number; attribute?: string; minLength?: number } = {}
): Promise<{ found: boolean; value: string | null; waitTime: number }> {
  const { timeout = 10000, attribute = 'content', minLength = 5 } = options;
  const startTime = Date.now();

  try {
    // Wait for element to appear
    await page.waitForSelector(selector, { timeout, state: 'attached' });
    
    // Wait for attribute to have content
    const value = await page.evaluate(
      ({ sel, attr, min }) => {
        const el = document.querySelector(sel);
        if (!el) return null;
        
        const value = attr === 'textContent' 
          ? el.textContent?.trim()
          : el.getAttribute(attr)?.trim();
        
        if (!value || value.length < min) return null;
        return value;
      },
      { sel: selector, attr: attribute, min: minLength }
    );

    return {
      found: !!value,
      value,
      waitTime: Date.now() - startTime
    };
  } catch (error) {
    return {
      found: false,
      value: null,
      waitTime: Date.now() - startTime
    };
  }
}

/**
 * Enhanced page.goto with SEO-ready waiting
 */
export async function navigateAndWaitForSeo(
  page: Page,
  url: string,
  options: {
    timeout?: number;
    seoReadyConfig?: Partial<SeoReadyConfig>;
  } = {}
): Promise<{
  timing: RenderTiming;
  seoReady: SeoReadyResult;
}> {
  const { timeout = 30000, seoReadyConfig = {} } = options;
  const navigationStart = Date.now();
  
  let timeToDomReady = 0;
  let timeToNetworkIdle = 0;

  // Navigate and wait for DOMContentLoaded
  const response = await page.goto(url, {
    timeout,
    waitUntil: 'domcontentloaded'
  });

  if (!response) {
    throw new Error(`Failed to load URL: ${url}`);
  }

  timeToDomReady = Date.now() - navigationStart;

  // Wait for network to be relatively idle
  try {
    await page.waitForLoadState('networkidle', { timeout: timeout / 2 });
    timeToNetworkIdle = Date.now() - navigationStart;
  } catch {
    // Network idle timeout is acceptable, continue with SEO check
    timeToNetworkIdle = Date.now() - navigationStart;
  }

  // Now wait for SEO elements
  const seoReady = await waitForSeoReady(page, {
    ...seoReadyConfig,
    debug: seoReadyConfig.debug ?? false
  });

  const totalRenderTime = Date.now() - navigationStart;

  return {
    timing: {
      timeToDomReady,
      timeToNetworkIdle,
      timeToSeoReady: timeToDomReady + seoReady.waitTime,
      totalRenderTime,
      seoReadyTimedOut: seoReady.timedOut
    },
    seoReady
  };
}

export default {
  waitForSeoReady,
  waitForSeoElement,
  navigateAndWaitForSeo,
  DEFAULT_SEO_READY_CONFIG
};
